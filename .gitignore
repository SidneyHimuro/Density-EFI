#include <LiquidCrystal.h>
#include <EEPROM.h>

// ================= LCD =================
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// ================= ESTADOS DO MENU =================
enum MenuState { MENU_PRINCIPAL, MONITORAMENTO, MAPA_INJ, MAPA_IGN, FUNCOES, CONFIGURACAO };
MenuState estadoAtual = MENU_PRINCIPAL;
int menuCursor = 0;
const int totalMenus = 5;
String nomesMenus[] = {"MONITORAMENTO ", "MAPA INJCAO     ", "MAPA IGNICAO     ", "FUNCOES        ", "CONFIGURACAO  "};

// Variáveis de Interface
int editR = 0, editM = 0; 
byte campoFoco = 0; 
bool modoConfirmacao = false;
int selecaoConfirmar = 0; 
unsigned long tempoBotaoRetido = 0;
int intervaloAceleracao = 250; 
unsigned long lastBtnPress = 0; 

// ================= SENSORES E FILTRAGEM =================
const byte mapPin = A4;
const byte tpsPin = A3; 
int tpsMinADC = 100, tpsMaxADC = 900; 
int mapAtmosADC = 940; 
float mapBar = 0.0, tpsPercent = 0.0;
float mapFiltrado = 0.0; 

// ================= RPM / RODA FÔNICA =================
const byte rpmPin = 21;
byte pulsesPerRev = 60; 
const byte INJ_TOOTH = 21; // Dente para disparar a injeção
volatile unsigned long lastPulseMicros = 0, periodMicros = 0, avgPeriod = 0;
volatile byte toothCount = 0;
volatile bool syncOK = false;
unsigned int rpm = 0;

// ================= INJETOR =================
#define INJ_PIN 22
volatile bool injectorOn = false;
volatile unsigned int injPulseTicksLatched = 0; // Calculado no loop, lido na ISR
float Tinj_latched = 0.0;

// ================= AE TPS (ACELERAÇÃO RÁPIDA) =================
float tpsPrev = 0.0;
unsigned long tpsPrevTime = 0;
float AE_TPS = 0.0;
float AE_TPS_max = 3.0;        
float AE_decay_ms = 250.0;     
float AE_decay_step = 0.0;
const float TPSDOT_MIN = 60.0; // Sensibilidade para evitar ruído

// ================= MAPA E EIXOS =================
const int rpmAxis[16] = {500, 800, 1200, 1600, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500};
const float mapAxis[16] = {0.0,-0.07,-0.14,-0.21,-0.28,-0.35,-0.42,-0.49,-0.56,-0.63,-0.70,-0.77,-0.84,-0.91,-0.96,-1.0};
float injTable[16][16]; 

// Endereços EEPROM
const int addrTPSMin = 1030, addrTPSMax = 1034, addrMAPAtmos = 1038, addrSinalRPM = 1042, addrAEMax = 1046, addrAEDecay = 1050;

// ================= ISR DO TIMER 3 (FECHAMENTO DO INJETOR) =================
ISR(TIMER3_COMPA_vect) {
  digitalWrite(INJ_PIN, LOW);
  injectorOn = false;
  TIMSK3 &= ~(1 << OCIE3A); // Desliga interrupção
}

// ================= ISR DE ROTAÇÃO (ABERTURA DO INJETOR) =================
void rpmISR() {
  unsigned long now = micros();
  unsigned long p = now - lastPulseMicros;
  lastPulseMicros = now;

  if (pulsesPerRev == 60) { // Lógica Roda Fônica
    if (avgPeriod == 0) avgPeriod = p;
    else avgPeriod = (avgPeriod * 7 + p) / 8;

    if (p > avgPeriod * 1.6) { // Gap detectado
      toothCount = 0;
      syncOK = true;
    } else if (syncOK) {
      toothCount++;
      if (toothCount >= pulsesPerRev) toothCount = 0;
    }

    // DISPARO IMEDIATO: Garante estabilidade no osciloscópio
    if (syncOK && toothCount == INJ_TOOTH && !injectorOn) {
      if (injPulseTicksLatched > 100) { // Min 50us para segurança
        digitalWrite(INJ_PIN, HIGH);
        injectorOn = true;
        TCNT3 = 0; 
        OCR3A = injPulseTicksLatched;
        TIFR3 |= (1 << OCF3A); 
        TIMSK3 |= (1 << OCIE3A);
      }
    }
  } else { // Distribuidor
    syncOK = true;
    digitalWrite(INJ_PIN, HIGH);
    injectorOn = true;
    TCNT3 = 0;
    OCR3A = injPulseTicksLatched;
    TIMSK3 |= (1 << OCIE3A);
  }
  periodMicros = p;
}

// ================= SETUP =================
void setup() {
  lcd.begin(16, 2);
  Serial.begin(115200);
  carregarTabela();
  
  pinMode(rpmPin, INPUT_PULLUP);
  pinMode(INJ_PIN, OUTPUT);
  digitalWrite(INJ_PIN, LOW);

  // Configuração Timer 3 (Modo CTC, Prescaler 8 = 0.5us por tick)
  TCCR3A = 0;
  TCCR3B = (1 << WGM32) | (1 << CS31);

  attachInterrupt(digitalPinToInterrupt(rpmPin), rpmISR, RISING);
  
  lcd.setCursor(0, 0); lcd.print("HimuroPerformance");
  lcd.setCursor(0, 1); lcd.print("Fixed EFI v1.1");
  delay(1500); lcd.clear();
}

// ================= LOOP =================
void loop() {
  // 1. LEITURA E FILTRAGEM (Remove jitter de sensores)
  int mapRaw = analogRead(mapPin);
  mapFiltrado = (mapFiltrado * 0.7) + (mapRaw * 0.3); // Média móvel exponencial
  mapBar = constrain((mapFiltrado - mapAtmosADC) / 920.0, -1.0, 0.0);

  int tpsRaw = analogRead(tpsPin);
  float tpsLido = constrain((float)(tpsRaw - tpsMinADC) * 100.0 / (tpsMaxADC - tpsMinADC), 0, 100);
  tpsPercent = (tpsPercent * 0.5) + (tpsLido * 0.5);

  // 2. CÁLCULO DE RPM
  unsigned long p;
  noInterrupts(); p = periodMicros; interrupts();
  if (p > 0 && (micros() - lastPulseMicros) < 250000) {
    rpm = (pulsesPerRev == 60) ? (60000000UL / (p * 60)) : (30000000UL / p);
  } else {
    rpm = 0; syncOK = false;
  }

  // 3. ACELERAÇÃO RÁPIDA (AE)
  unsigned long agora = millis();
  if (agora - tpsPrevTime > 20) {
    float dt = (agora - tpsPrevTime) / 1000.0;
    float tpsDot = (tpsPercent - tpsPrev) / dt;
    
    if (tpsDot > TPSDOT_MIN && rpm > 400) {
      AE_TPS = (tpsDot > 250) ? AE_TPS_max : (AE_TPS_max * 0.6);
      AE_decay_step = AE_TPS / (AE_decay_ms / 20.0);
    } else if (AE_TPS > 0) {
      AE_TPS -= AE_decay_step;
      if (AE_TPS < 0) AE_TPS = 0;
    }
    tpsPrev = tpsPercent;
    tpsPrevTime = agora;
  }

  // 4. CÁLCULO DO TEMPO DE INJEÇÃO
  if (rpm > 100) {
    float Tbase = interp2D(rpm, mapBar);
    Tinj_latched = Tbase + AE_TPS;
    // Converte ms para ticks (1ms = 2000 ticks)
    noInterrupts();
    injPulseTicksLatched = (unsigned int)(Tinj_latched * 2000.0);
    interrupts();
  }

  // 5. GERENCIAMENTO DE MENUS (Não bloqueante)
  atualizarInterface();
}

// ================= FUNÇÕES DE APOIO =================

float interp2D(int rpmVal, float mapVal) {
  byte iR = 0, iM = 0;
  while (iR < 14 && rpmVal > rpmAxis[iR + 1]) iR++;
  while (iM < 14 && mapVal < mapAxis[iM + 1]) iM++;
  float fr = (float)(rpmVal - rpmAxis[iR]) / (rpmAxis[iR + 1] - rpmAxis[iR]);
  float fm = (float)(mapVal - mapAxis[iM]) / (mapAxis[iM + 1] - mapAxis[iM]);
  float a = injTable[iR][iM] + fr * (injTable[iR + 1][iM] - injTable[iR][iM]);
  float b = injTable[iR][iM + 1] + fr * (injTable[iR + 1][iM + 1] - injTable[iR][iM + 1]);
  return a + fm * (b - a);
}

void carregarTabela() {
  float val;
  EEPROM.get(0, val);
  if (!isnan(val) && val > 0.05) {
    int addr = 0;
    for (int i = 0; i < 16; i++) {
      for (int j = 0; j < 16; j++) {
        EEPROM.get(addr, injTable[i][j]);
        addr += sizeof(float);
      }
    }
    EEPROM.get(addrTPSMin, tpsMinADC);
    EEPROM.get(addrTPSMax, tpsMaxADC);
    EEPROM.get(addrMAPAtmos, mapAtmosADC);
    EEPROM.get(addrSinalRPM, pulsesPerRev);
    EEPROM.get(addrAEMax, AE_TPS_max);
    EEPROM.get(addrAEDecay, AE_decay_ms);
  } else {
    for(int i=0; i<16; i++) for(int j=0; j<16; j++) injTable[i][j] = 2.0;
  }
}

void salvarTabela() {
  int addr = 0;
  for (int i = 0; i < 16; i++) {
    for (int j = 0; j < 16; j++) {
      EEPROM.put(addr, injTable[i][j]);
      addr += sizeof(float);
    }
  }
}

// ================= LOGICA DE INTERFACE (RESUMIDA) =================
void atualizarInterface() {
  static unsigned long tLCD = 0;
  if (millis() - tLCD < 100) return;
  tLCD = millis();

  int btn = lerBotao();
  unsigned long m = millis();
  bool blink = (m / 400) % 2;

  // Lógica de navegação de menus (similar à sua original, porém otimizada)
  if (estadoAtual == MONITORAMENTO) {
    if (btn == 4) { estadoAtual = MENU_PRINCIPAL; lcd.clear(); lastBtnPress = m; }
    lcd.setCursor(0, 0); lcd.print("RPM:"); lcd.print(rpm); lcd.print("    ");
    lcd.setCursor(9, 0); lcd.print("T:"); lcd.print((int)tpsPercent); lcd.print("% ");
    lcd.setCursor(0, 1); lcd.print("MAP:"); lcd.print(mapBar, 2);
    lcd.setCursor(9, 1); lcd.print(Tinj_latched, 2); lcd.print("ms");
  } 
  else if (estadoAtual == MENU_PRINCIPAL) {
    if (m - lastBtnPress > 200) {
      if (btn == 2) { menuCursor = (menuCursor - 1 + totalMenus) % totalMenus; lcd.clear(); lastBtnPress = m; }
      if (btn == 3) { menuCursor = (menuCursor + 1) % totalMenus; lcd.clear(); lastBtnPress = m; }
      if (btn == 5) { estadoAtual = (MenuState)(menuCursor + 1); lcd.clear(); lastBtnPress = m; }
    }
    lcd.setCursor(0,0); lcd.print("> "); lcd.print(nomesMenus[menuCursor]);
  }
  // (Adicione os outros submenus conforme necessário seguindo o padrão original)
}
